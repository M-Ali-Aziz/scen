<?php

/**
 * Implements hook_field_formatter_info().
 */
function sushi_field_formatter_info() {
  return array(
    'sushi_cut' => array(
      'label' => t('Sushi cut'),
      'field types' => array('text', 'text_long', 'text_with_summary'),
      'settings' => array(
        'max_length' => 600,
        'word_boundary' => TRUE,
        'ellipsis' => '...',
      ),
    ),
  );
}

/**
 * Implements hook_field_formatter_settings_form().
 */
function sushi_field_formatter_settings_form($field, $instance, $view_mode, $form, &$form_state) {
  $display = $instance['display'][$view_mode];
  $settings = $display['settings'];

  $form['max_length'] = array(
    '#title' => t('Max length'),
    '#type' => 'textfield',
    '#size' => 10,
    '#default_value' => $settings['max_length'], 
    '#element_validate' => array('element_validate_integer_positive'),
    '#required' => TRUE,
  );
  $form['word_boundary'] = array(
    '#title' => t('Cut only on word boundary'),
    '#type' => 'checkbox',
    '#default_value' => $settings['word_boundary'], 
  );
  $form['ellipsis'] = array(
    '#title' => t('Ellipsis'),
    '#type' => 'textfield',
    '#size' => 10,
    '#default_value' => $settings['ellipsis'], 
  );

  return $form;
}

/**
 * Implements hook_field_formatter_settings_summary().
 */
function sushi_field_formatter_settings_summary($field, $instance, $view_mode) {
  $display = $instance['display'][$view_mode];
  $settings = $display['settings'];

  $summary[] = t('Max length') . ': ' . $settings['max_length'];
  $summary[] = t('Word boundary') . ': ' . ($settings['word_boundary'] ? t('Yes') : t('No'));
  $summary[] = t('Ellipsis') . ': ' . $settings['ellipsis'];

  return implode('<br />', $summary);
}

/**
 * Implements hook_field_formatter_view().
 */
function sushi_field_formatter_view($entity_type, $entity, $field, $instance, $langcode, $items, $display) {
  $element = array();

  foreach ($items as $delta => $item) {
    $output = _text_sanitize($instance, $langcode, $item, 'value');
    $output = sushi_cut_text($output, $instance['settings']['text_processing'] ? $item['format'] : NULL, $display['settings']['max_length'], $display['settings']['word_boundary'], $display['settings']['ellipsis']);
    $element[$delta] = array('#markup' => $output);
  }

  return $element;
}

/**
 * Cuts the text to match the specified length.
 *
 * This has been inspired by text_summary().
 *
 * @see text_summary().
 */
function sushi_cut_text($text, $format = NULL, $size = 600, $word_boundary = TRUE, $ellipsis = '...') {

  // Make room for the ellipsis.
  if (isset($ellipsis) && strlen($ellipsis) > 0) {
    $size -= strlen($ellipsis);
  }

  // Find where the delimiter is in the body
  $delimiter = strpos($text, '<!--break-->');

  // If the size is zero, and there is no delimiter, the entire body is the summary.
  if ($size == 0 && $delimiter === FALSE) {
    return $text;
  }

  // If a valid delimiter has been specified, use it to chop off the summary.
  if ($delimiter !== FALSE) {
    return substr($text, 0, $delimiter);
  }

  // We check for the presence of the PHP evaluator filter in the current
  // format. If the body contains PHP code, we do not split it up to prevent
  // parse errors.
  if (isset($format)) {
    $filters = filter_list_format($format);
    if (isset($filters['php_code']) && $filters['php_code']->status && strpos($text, '<?') !== FALSE) {
      return $text;
    }
  }

  // If we have a short body, the entire body is the summary.
  if (drupal_strlen($text) <= $size) {
    return $text;
  }

  // If the delimiter has not been specified, try to split at paragraph or
  // sentence boundaries.

  // The summary may not be longer than maximum length specified. Initial slice.
  $summary = truncate_utf8($text, $size);

  // Store the actual length of the UTF8 string -- which might not be the same
  // as $size.
  $max_rpos = strlen($summary);

  // How much to cut off the end of the summary so that it doesn't end in the
  // middle of a paragraph, sentence, or word.
  // Initialize it to maximum in order to find the minimum.
  $min_rpos = $max_rpos;

  // Store the reverse of the summary. We use strpos on the reversed needle and
  // haystack for speed and convenience.
  $reversed = strrev($summary);

  // Add some break points in case we don't want to cut in the middle of a word.
  if ($word_boundary) {
    $break_points[] = array(
      ' ' => 1,
    );
    // A paragraph near the end of sliced summary is most preferable.
    $break_points[] = array('</p>' => 0);

    // If no complete paragraph then treat line breaks as paragraphs.
    $line_breaks = array(
      '<br />' => 6,
      '<br>' => 4,
    );
    // Newline only indicates a line break if line break converter
    // filter is present.
    if (isset($filters['filter_autop'])) {
      $line_breaks["\n"] = 1;
    }
    $break_points[] = $line_breaks;
    
    // Iterate over the groups of break points until a break point is found.
    foreach ($break_points as $points) {
      // Look for each break point, starting at the end of the summary.
      foreach ($points as $point => $offset) {
        // The summary is already reversed, but the break point isn't.
        $rpos = strpos($reversed, strrev($point));
        if ($rpos !== FALSE) {
          $min_rpos = min($rpos + $offset, $min_rpos);
        }
      }
  
      // If a break point was found in this group, slice and stop searching.
      if ($min_rpos !== $max_rpos) {
        // Don't slice with length 0. Length must be <0 to slice from RHS.
        $summary = ($min_rpos === 0) ? $summary : substr($summary, 0, 0 - $min_rpos);
        break;
      }
    }
  }
  else {
    $summary = substr($summary, 0, $size);
  }

  // If the htmlcorrector filter is present, apply it to the generated summary.
  if (isset($filters['filter_htmlcorrector'])) {
    $summary = _filter_htmlcorrector($summary);
  }

  return $ellipsis ? trim($summary) . $ellipsis : trim($summary);
}
