<?php
/**
 * @file
 * Main module file for the Treadmill module.
 *
 * This is a custom module that extracts the archives that came from the
 * production environment. These archives will contain a backup of the files
 * directory.
 */

/**
 * Implements hook_menu().
 */
function treadmill_menu() {
  // Only enable the Backup and Migrate cooperation if that module exists.
  if (module_exists('backup_migrate')) {
    $items['admin/config/system/backup_migrate/treadmill'] = array(
      'title' => 'Treadmill',
      'page callback' => 'drupal_get_form',
      'page arguments' => array('treadmill_form'),
      'access arguments' => array('configure treadmill'),
      'type' => MENU_LOCAL_TASK,
      'weight' => 10,
    );
  }

  // Callback that runs update.php.
  $items['treadmill/system/update'] = array(
    'page callback' => 'treadmill_system_update',
    'access callback' => 'treadmill_remote_access',
    'type' => MENU_CALLBACK,
  );

  // Callback that reverts every feature.
  $items['treadmill/features/revert'] = array(
    'page callback' => 'treadmill_features_revert',
    'access callback' => 'treadmill_remote_access',
    'type' => MENU_CALLBACK,
  );

  return $items;
}

/**
 * Implements hook_permission().
 */
function treadmill_permission() {
  return array(
    'configure treadmill' => array(
      'title' => 'Configure treadmill settings',
    ),
  );
}

/**
 * General access callback for remote execution.
 *
 * This will verify the key that has been supplied in the query string. We will
 * use the same key as the cron key, for convenience.
 */
function treadmill_remote_access() {
  return isset($_GET['key']) && variable_get('cron_key', 'drupal') == $_GET['key'];
}

/**
 * Page callback for treadmill/system/update.
 *
 * @see update_main_prepare()
 * @see update_main()
 * @see update_batch()
 */
function treadmill_system_update() {
  // We prepare a minimal bootstrap for the update requirements check to avoid
  // reaching the PHP memory limit.
  require_once DRUPAL_ROOT . '/includes/bootstrap.inc';
  require_once DRUPAL_ROOT . '/includes/common.inc';
  require_once DRUPAL_ROOT . '/includes/file.inc';
  require_once DRUPAL_ROOT . '/includes/entity.inc';
  include_once DRUPAL_ROOT . '/includes/unicode.inc';

  drupal_bootstrap(DRUPAL_BOOTSTRAP_SESSION);

  require_once DRUPAL_ROOT . '/includes/update.inc';
  require_once DRUPAL_ROOT . '/includes/install.inc';
  require_once DRUPAL_ROOT . '/modules/system/system.install';

  // Load module basics.
  include_once DRUPAL_ROOT . '/includes/module.inc';
  $module_list['system']['filename'] = 'modules/system/system.module';
  module_list(TRUE, FALSE, FALSE, $module_list);
  drupal_load('module', 'system');

  // Reset the module_implements() cache so that any new hook implementations
  // in updated code are picked up.
  module_implements('', FALSE, TRUE);

  // Set up $language, since the installer components require it.
  drupal_language_initialize();

  // Set up theme system for the maintenance page.
  drupal_maintenance_theme();

  // Now proceed with a full bootstrap.
  drupal_bootstrap(DRUPAL_BOOTSTRAP_FULL);

  include_once DRUPAL_ROOT . '/includes/batch.inc';
  drupal_load_updates();

  update_fix_compatibility();

   // Change query-strings on css/js files to enforce reload for all users.
  _drupal_flush_css_js();
  // Flush the cache of all data for the update status module.
  if (db_table_exists('cache_update')) {
    cache_clear_all('*', 'cache_update', TRUE);
  }

  module_list(TRUE, FALSE, TRUE);

  $pending = update_get_update_list();

  $start = array();

  // Ensure system module's updates run first.
  $start['system'] = array();

  // Print a list of pending updates for this module and get confirmation.
  if (sizeof($pending)) {
    foreach ($pending as $module => $updates) {
      if (isset($updates['start']))  {
        $start[$module] = $updates['start'];
      }
    }

    // Resolve any update dependencies to determine the actual updates that will
    // be run and the order they will be run in.
    $updates = update_resolve_dependencies($start);

    // Store the dependencies for each update function in an array which the
    // batch API can pass in to the batch operation each time it is called. (We
    // do not store the entire update dependency array here because it is
    // potentially very large.)
    $dependency_map = array();
    foreach ($updates as $function => $update) {
      $dependency_map[$function] = !empty($update['reverse_paths']) ? array_keys($update['reverse_paths']) : array();
    }

    // Create "batch" operations for each update.
    $operations = array();
    foreach ($updates as $update) {
      if ($update['allowed']) {
        // Set the installed version of each module so updates will start at the
        // correct place. (The updates are already sorted, so we can simply base
        // this on the first one we come across in the above foreach loop.)
        if (isset($start[$update['module']])) {
          drupal_set_installed_schema_version($update['module'], $update['number'] - 1);
          unset($start[$update['module']]);
        }
        // Add this update function to the batch.
        $function = $update['module'] . '_update_' . $update['number'];
        $operations[] = array('update_do_one', array($update['module'], $update['number'], $dependency_map[$function]));
      }
    }

    // Run each "batch" operation manually.
    foreach ($operations as $operation) {
      $module = $operation[1][0];
      $number = $operation[1][1];
      $dependency_map = $operation[1][2];
      $context = array('finished' => 1);
      $operation[0]($module, $number, $dependency_map, $context);
    }
  }
}

/**
 * Page callback for treadmill/features/revert.
 *
 * @see ftools_features_revert_all_submit()
 */
function treadmill_features_revert() {
  // Include the necessary files and revert all features.
  module_load_include('inc', 'features', 'features.export');
  features_include();
  features_revert();

  // Clear the cache, and exit.
  cache_clear_all();
  exit();
}

/**
 * Main configuration form.
 */
function treadmill_form($form, &$form_state) {
  // Get the settings, and the available Backup and Migrate destinations.
  $settings = treadmill_get_settings();
  backup_migrate_include('profiles', 'destinations');
  $destinations = _backup_migrate_get_destination_form_item_options('manual backup');

  $visible_states = array();
  foreach ($destinations as $key => $label) {
    $visible_states[]['[name=treadmill_destination]'] = array('value' => $key);
  }

  // Global settings.
  $form['global'] = array(
    '#type' => 'fieldset',
    '#title' => t('Global settings'),
    '#collapsible' => TRUE,
  );
  $form['global']['treadmill_destination'] = array(
    '#type' => 'select',
    '#title' => 'Triggering destination',
    '#options' => array('' => t('- None -')) + $destinations,
    '#default_value' => $settings['destination'],
    '#description' => t('Select the Backup and Migrate destination that should trigger Treadmill.'),
  );
  $form['global']['treadmill_url'] = array(
    '#type' => 'textfield',
    '#title' => 'Destination URL',
    '#description' => t('The full base url for the destination site including a trailing slash, e.g. %example.', array('%example' => 'http://example.oddserver.se/')),
    '#required' => TRUE,
    '#default_value' => $settings['url'],
    '#states' => array(
      'visible' => $visible_states,
    ),
  );
  $form['global']['treadmill_key'] = array(
    '#type' => 'textfield',
    '#title' => 'Access key',
    '#required' => TRUE,
    '#default_value' => $settings['key'],
    '#states' => array(
      'visible' => $visible_states,
    ),
  );

  // Features specific settings.
  $form['features'] = array(
    '#type' => 'fieldset',
    '#title' => t('Features settings'),
    '#collapsible' => TRUE,
    '#states' => array(
      'visible' => $visible_states,
    ),
  );
  $form['features']['treadmill_features_revert'] = array(
    '#type' => 'checkbox',
    '#title' => 'Revert features for the destination site.',
    '#default_value' => $settings['features_revert'],
  );

  // Tadaa! specific settings.
  $form['tadaa'] = array(
    '#type' => 'fieldset',
    '#title' => t('Tadaa! settings'),
    '#collapsible' => TRUE,
    '#states' => array(
      'visible' => $visible_states,
    ),
  );
  $form['tadaa']['treadmill_environment_switch'] = array(
    '#type' => 'checkbox',
    '#title' => 'Switch environment for the destination site.',
    '#default_value' => $settings['tadaa_switch'],
  );
  $form['tadaa']['treadmill_environment'] = array(
    '#type' => 'textfield',
    '#title' => 'Environment machine name',
    '#description' => t('Enter the name of the environment that should be activated once the backup has finished, e.g. %example.', array('%example' => 'staging')),
    '#states' => array(
      'visible' => array(
        '[name=treadmill_environment_switch]' => array('checked' => TRUE),
      ),
      'required' => array(
        '[name=treadmill_environment_switch]' => array('checked' => TRUE),
      ),
    ),
    '#default_value' => $settings['tadaa_environment'],
  );

  return system_settings_form($form);
}

/**
 * Form validation for the main configuration form.
 */
function treadmill_form_validate($form, &$form_state) {
  // Validate the URL.
  if (!valid_url($form_state['values']['treadmill_url'], TRUE)) {
    form_set_error('url', t("%url isn't a valid URL.", array('%url' => $form_state['values']['treadmill_url'])));
  }

  // Make sure that the URL has a trailing slash.
  if (!preg_match('/\/$/', $form_state['values']['treadmill_url'])) {
    form_set_error('url', t('The URL has to end with a trailing slash.'));
  }

  // Verify that we have an environment name if the user has enabled the
  // environment switch.
  if ($form_state['values']['treadmill_environment_switch'] && empty($form_state['values']['treadmill_environment'])) {
    form_set_error('environment', t('Environment machine name field is required.'));
  }
}

/**
 * Implements hook_backup_migrate_postbackup().
 */
function treadmill_backup_migrate_postbackup($backup_migrate_settings) {
  // Get the destination that the backup was performed against, and get the
  // Treadmill settings.
  $destination = $backup_migrate_settings->get_destination()->destination_id;
  $settings = treadmill_get_settings();

  // Don't do anything if this isn't the configured destination.
  if (empty($settings['destination']) || $settings['destination'] != $destination) {
    return;
  }

  // Build the URL and the base query.
  $url = $settings['url'];
  $query = array('key' => $settings['key']);

  // Perform the system update.
  $query['q'] = 'treadmill/system/update';
  drupal_http_request(url($url, array('query' => $query)));

  // Perform the Features revert.
  if ($settings['features_revert']) {
    $query['q'] = 'treadmill/features/revert';
    drupal_http_request(url($url, array('query' => $query)));
  }

  // Perform the Tadaa! environment switch.
  if ($settings['tadaa_switch']) {
    $query['q'] = 'tadaa/environment/switch/' . $settings['tadaa_environment'];
    drupal_http_request(url($url, array('query' => $query)));
  }
}

/**
 * Helper function that gets the settings.
 *
 * @return
 *  An array with the values, keyed by the name.
 */
function treadmill_get_settings() {
  return array(
    'destination' => variable_get('treadmill_destination', ''),
    'url' => variable_get('treadmill_url', 'http://kund:kund@'),
    'key' => variable_get('treadmill_key', variable_get('cron_key', 'drupal')),
    'features_revert' => variable_get('treadmill_features_revert', FALSE),
    'tadaa_switch' => variable_get('treadmill_environment_switch', FALSE),
    'tadaa_environment' => variable_get('treadmill_environment', 'staging'),
  );
}